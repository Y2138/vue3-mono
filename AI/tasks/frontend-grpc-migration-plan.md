# 前端 GraphQL → gRPC 迁移开发计划

> **项目目标**：将 Vue3 前端从 GraphQL 架构迁移到 gRPC + REST 双协议架构
> 
> **技术栈**：Vue 3 + TypeScript + Vite + Naive UI + Pinia + gRPC-Web
> 
> **开发周期**：预计 3-4 周
> 
> **负责模块**：前端应用层（apps/naive-admin）

---

## 📋 迁移概览

| 当前技术栈 | 目标技术栈 | 改动类型 |
|------------|------------|----------|
| Apollo Client + GraphQL | gRPC-Web + Axios | 🔄 重大重构 |
| GraphQL Queries/Mutations | Protobuf Messages | 🔄 重大重构 |
| useQuery, useMutation | API Client + Pinia | 🔄 重大重构 |
| 手动类型定义 | Protobuf 自动生成 | 🔄 重大重构 |

---

## 🎯 阶段一：构建工具和环境配置（第1周）

### 步骤 1.1：配置 Vite 支持 Protobuf
**目标**：增强 Vite 构建配置以支持 Protobuf 编译

**具体任务**：
- [ ] 安装 Protobuf 相关依赖
  - `vite-plugin-proto`
  - `@improbable-eng/grpc-web`
  - `@improbable-eng/grpc-web-webtext-transport`
  - `google-protobuf`
  - `ts-proto`
- [ ] 配置 Vite 插件
  - 添加 `protoPlugin` 到 `vite.config.ts`
  - 配置 proto 文件输入路径
  - 设置 TypeScript 输出目录 `src/shared`
- [ ] 配置环境变量支持
  - 添加 `VITE_GRPC_ENDPOINT` 配置
  - 添加 `VITE_PREFER_GRPC` 协议选择配置

**产出物**：
- 更新的 `vite.config.ts` 文件
- 新的环境变量配置文件

**验收标准**：
- Vite 构建无错误
- Protobuf 编译正常
- 环境变量正确加载

---

### 步骤 1.2：清理 GraphQL 相关依赖
**目标**：移除所有 GraphQL 相关的包和配置

**具体任务**：
- [ ] 卸载 GraphQL 相关依赖
  - `@apollo/client`
  - `graphql`
  - `@vue/apollo-composable`
- [ ] 删除 GraphQL 配置文件
  - Apollo Client 配置文件
  - GraphQL 查询文件
- [ ] 清理导入引用
  - 搜索并删除所有 GraphQL 相关导入
  - 删除未使用的类型定义
- [ ] 更新 `package.json`

**产出物**：
- 清理后的依赖列表
- 删除的 GraphQL 配置文件

**验收标准**：
- 项目构建无 GraphQL 相关错误
- 依赖包大小减少
- 代码中无遗留 GraphQL 引用

---

### 步骤 1.3：建立 Protobuf 类型生成流程
**目标**：建立自动化的 Protobuf 类型生成和更新机制

**具体任务**：
- [ ] 配置编译脚本
  - 添加 `proto:gen` 脚本到 `package.json`
  - 添加 `proto:watch` 监听脚本
  - 配置 `dev:with-proto` 开发脚本
- [ ] 创建 `src/shared/` 目录结构
  - 为生成的类型文件准备目录
  - 添加 `.gitignore` 规则
- [ ] 测试类型生成
  - 验证 proto 文件编译
  - 检查生成的 TypeScript 类型
  - 测试类型导入功能

**产出物**：
- 自动化编译脚本
- `src/shared/` 类型目录
- 生成的 TypeScript 类型文件

**验收标准**：
- 编译脚本正常执行
- 生成的类型文件语法正确
- IDE 类型提示正常工作

---

### 步骤 1.4：配置开发环境变量
**目标**：建立支持双协议开发的环境配置

**具体任务**：
- [ ] 创建环境变量文件
  - `.env.development` - 开发环境配置
  - `.env.production` - 生产环境配置
  - `.env.local` - 本地个人配置模板
- [ ] 配置 gRPC 相关变量
  - `VITE_GRPC_ENDPOINT` - gRPC 服务地址
  - `VITE_API_URL` - REST API 地址
  - `VITE_PREFER_GRPC` - 协议偏好设置
- [ ] 配置调试相关变量
  - `VITE_PROTO_DEBUG` - Protobuf 调试模式
  - `VITE_DEV_TOOLS` - 开发工具启用
- [ ] 更新 TypeScript 配置

**产出物**：
- 完整的环境变量配置
- 更新的 TypeScript 配置

**验收标准**：
- 环境变量正确加载
- 不同环境配置隔离
- 开发体验优化

---

## 🔧 阶段二：简化API层重构（第2周）

### 步骤 2.1：创建统一API适配器
**目标**：创建一个简单的API适配器，支持HTTP/gRPC协议切换

**具体任务**：
- [ ] 创建 `src/request/api-adapter.ts`
  - 实现 `ApiAdapter` 类，封装HTTP和gRPC调用
  - 提供统一的 `call(endpoint, data)` 方法
  - 支持环境变量配置协议选择 `VITE_USE_GRPC=true/false`
  - 内置数据格式转换器，确保返回格式统一
- [ ] 实现协议适配逻辑
  - HTTP模式：使用现有axios实现
  - gRPC模式：调用gRPC服务，结果转换为HTTP格式
  - 错误处理统一化
- [ ] 添加Protobuf数据转换
  - 请求数据：JSON → Protobuf（仅gRPC模式）
  - 响应数据：Protobuf → JSON（确保格式统一）
  - 基于 `shared/` 类型定义进行转换验证

**产出物**：
- API适配器核心类
- 统一的数据转换器
- 协议配置管理

**验收标准**：
- 一套API调用方式，支持两种协议
- 返回数据格式完全统一
- 配置简单，易于维护

---

### 步骤 2.2：重构现有API调用
**目标**：将现有API调用迁移到新的适配器，保持接口不变

**具体任务**：
- [ ] 更新 `src/request/axios.ts`
  - 保持现有HTTP调用逻辑
  - 集成API适配器作为可选方案
  - 向后兼容现有调用方式
- [ ] 重构业务API模块
  - 更新 `src/request/api/users.ts` - 保持接口签名不变
  - 更新 `src/request/api/rbac.ts` - 保持接口签名不变
  - 更新 `src/request/api/common.ts` - 添加适配器支持
  - 所有API返回 `[data, error]` 格式保持不变
- [ ] 添加类型转换验证
  - 确保gRPC响应转换为shared类型格式
  - 添加运行时类型检查（开发模式）
  - 类型不匹配时的错误处理

**产出物**：
- 兼容现有接口的API模块
- 类型安全的数据转换
- 完整的错误处理

**验收标准**：
- 现有API调用方式100%保持不变
- gRPC模式下数据格式与HTTP模式完全一致
- 类型安全得到保障

---

### 步骤 2.3：简化配置和测试
**目标**：提供简单的配置方式和完整的测试覆盖

**具体任务**：
- [ ] 配置管理简化
  - 环境变量：`VITE_USE_GRPC=true/false`
  - 运行时切换：`window.__API_CONFIG__.useGrpc = true`
  - 调试模式：`VITE_API_DEBUG=true` 显示协议信息
- [ ] 创建兼容性测试
  - HTTP vs gRPC 数据格式一致性测试
  - API响应时间对比测试
  - 错误处理一致性测试
- [ ] 添加开发工具
  - API调用日志（显示使用的协议）
  - 数据格式验证工具
  - 性能监控面板

**产出物**：
- 简化的配置系统
- 完整的兼容性测试
- 开发调试工具

**验收标准**：
- 配置简单易用
- 测试覆盖完整
- 开发体验友好

---

## 🏗️ 阶段三：状态管理适配（第3周前半周）

### 步骤 3.1：状态管理无缝集成
**目标**：状态管理层保持不变，只适配新的API调用方式

**具体任务**：
- [ ] 更新 `src/store/modules/user.ts`
  - API调用保持现有方式不变
  - 利用API适配器的透明协议切换
  - 数据格式处理逻辑保持不变
- [ ] 更新 `src/store/modules/permission.ts`
  - 保持现有权限检查逻辑
  - API调用透明支持HTTP/gRPC
  - 缓存策略保持不变
- [ ] 优化 `src/store/modules/global.ts`
  - 添加API协议状态显示
  - 添加协议切换功能（开发模式）
  - 保持现有全局状态管理

**产出物**：
- 透明支持双协议的状态管理
- 协议状态监控
- 保持现有业务逻辑

**验收标准**：
- 状态管理逻辑99%保持不变
- 协议切换对业务逻辑透明
- 数据一致性得到保障

---

## 🎨 阶段四：组件层最小化适配（第3周后半周）

### 步骤 4.1：组件层透明支持
**目标**：组件层基本不变，只添加协议状态显示

**具体任务**：
- [ ] 核心业务组件保持不变
  - `src/views/operation-manage/column.vue` - 只需要显示协议状态
  - 所有API调用保持现有方式
  - 数据处理逻辑完全不变
- [ ] 添加协议状态组件
  - 创建 `src/components/api-status/index.vue`
  - 显示当前使用的协议（HTTP/gRPC）
  - 提供协议切换开关（开发模式）
- [ ] 表单组件简单增强
  - `src/components/dForm/` 组件保持现有功能
  - 可选添加基于shared类型的验证提示
  - 保持完全向后兼容

**产出物**：
- 保持现有功能的业务组件
- 协议状态显示组件
- 可选的类型验证增强

**验收标准**：
- 组件功能100%保持不变
- 协议切换对用户体验透明
- 开发者可以观察协议状态

---

### 步骤 4.2：开发体验优化
**目标**：为开发者提供协议调试工具

**具体任务**：
- [ ] 创建API调试面板
  - 显示API调用统计
  - 协议性能对比
  - 数据格式验证结果
- [ ] 添加错误诊断工具
  - gRPC连接状态检查
  - 数据转换错误提示
  - 协议切换建议
- [ ] 文档和示例更新
  - 更新组件使用文档
  - 添加协议配置说明
  - 提供最佳实践指南

**产出物**：
- 开发调试工具
- 错误诊断系统
- 完整文档

**验收标准**：
- 开发调试便捷
- 错误定位准确
- 文档清晰完整

---

## 🧪 阶段五：测试和部署（第4周）

### 步骤 5.1：兼容性测试
**目标**：确保HTTP和gRPC模式完全一致

**具体任务**：
- [ ] 数据一致性测试
  - 同一API的HTTP vs gRPC响应对比
  - 数据类型转换准确性验证
  - 边界情况处理测试
- [ ] 性能对比测试
  - HTTP vs gRPC 响应时间对比
  - 数据传输量对比
  - 错误率统计
- [ ] 用户体验测试
  - 协议切换无感知验证
  - 错误处理一致性测试
  - 界面响应速度测试

**产出物**：
- 完整的兼容性测试报告
- 性能对比数据
- 用户体验验证结果

**验收标准**：
- 数据一致性100%
- 性能差异在可接受范围
- 用户体验无差异

---

### 步骤 5.2：部署配置优化
**目标**：简化生产环境部署和配置

**具体任务**：
- [ ] 环境配置简化
  - 生产环境默认HTTP模式
  - 可选启用gRPC模式
  - 配置热更新支持
- [ ] 监控和日志
  - API协议使用统计
  - 错误率监控
  - 性能指标收集
- [ ] 回滚策略
  - 一键切换回HTTP模式
  - 渐进式gRPC启用
  - 故障自动降级

**产出物**：
- 简化的部署配置
- 完整的监控系统
- 可靠的回滚机制

**验收标准**：
- 部署配置简单
- 监控数据准确
- 故障处理及时

---

## 📊 简化后的质量控制

### 里程碑检查点

| 里程碑 | 时间节点 | 验收标准 | 风险评估 |
|--------|----------|----------|----------|
| **M1 - API适配器** | 第2周中 | 统一API调用，支持协议切换 | 低风险 |
| **M2 - API迁移** | 第2周末 | 现有API保持不变，兼容双协议 | 低风险 |
| **M3 - 状态管理** | 第3周中 | 状态管理透明支持双协议 | 低风险 |
| **M4 - 组件适配** | 第3周末 | 组件功能保持不变，添加状态显示 | 低风险 |
| **M5 - 测试部署** | 第4周末 | 完整测试通过，部署配置完成 | 低风险 |

### 简化设计优势

| 优势项 | 说明 | 收益 |
|--------|------|------|
| **维护成本低** | 一套API调用方式，一个配置开关 | 降低学习成本 |
| **风险可控** | 默认HTTP模式，gRPC可选启用 | 渐进式升级 |
| **向后兼容** | 现有代码99%保持不变 | 平滑迁移 |
| **调试友好** | 协议状态透明，错误定位清晰 | 提升开发效率 |

---

## 🚀 部署策略

### 分阶段启用
1. **第一阶段**：默认HTTP模式，内部测试gRPC
2. **第二阶段**：灰度启用gRPC模式（10%用户）
3. **第三阶段**：根据性能数据决定是否扩大gRPC使用

### 配置管理
```javascript
// 环境变量配置
VITE_USE_GRPC=false           // 默认HTTP模式
VITE_API_DEBUG=true           // 开发模式显示协议信息
VITE_GRPC_ENDPOINT=localhost:9090  // gRPC服务地址

// 运行时配置
window.__API_CONFIG__ = {
  useGrpc: false,             // 协议选择
  debug: true,                // 调试模式
  autoFallback: true          // 自动降级
}
```

---

> **总结**：简化后的方案以**最小化改动、最大化兼容**为原则，确保gRPC集成对现有业务逻辑透明，同时提供灵活的配置选项和完整的开发工具支持。 