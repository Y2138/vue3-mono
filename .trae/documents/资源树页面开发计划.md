# 资源树页面开发计划

## 1. 需求分析

### 1.1 功能需求
- 树形展示所有资源，使用 n-tree 组件
- 默认展开所有页面节点
- 顶部输入框，支持中文名过滤树结构
- 树节点区分不同类型（页面、模块、接口）的资源展示 UI
- 操作按钮：编辑、添加下级、删除、查看

### 1.2 技术栈
- Vue 3 + TypeScript
- Naive UI 组件库
- @iconify/vue 图标库
- 现有的 API 接口

## 2. 页面设计与结构

### 2.1 组件结构
```
/src/views/system/resources/
├── index.vue              # 现有资源列表页面
├── tree.vue               # 新增资源树页面
└── components/
    ├── ResourceForm.vue   # 现有资源表单组件
    └── ResourceTreeItem.vue # 新增资源树节点组件
```

### 2.2 路由配置
在 `/src/router/modules/system.ts` 中添加资源树路由：
```typescript
{
  path: 'resource/tree',
  name: 'resourceTree',
  component: () => import('@/views/system/resources/tree.vue'),
  meta: {
    title: '资源树',
    activeMenuPath: '/system-manage/resource'
  }
}
```

## 3. 核心功能实现

### 3.1 资源树数据获取与处理

1. **API 调用**：使用 `getResourceTree` 接口获取资源树数据
2. **数据转换**：将返回的 `ResourceTree[]` 数据转换为 n-tree 组件所需的格式
3. **默认展开处理**：根据资源类型（type=1 为页面）默认展开所有页面节点

### 3.2 搜索过滤功能

1. **搜索输入框**：使用 n-input 组件实现中文名搜索
2. **过滤逻辑**：根据输入的名称过滤树节点，保留匹配节点及其父节点
3. **实时过滤**：输入时实时更新过滤结果

### 3.3 资源类型 UI 区分

1. **类型映射**：
   - 页面（type=1）：蓝色标签
   - 模块（type=3）：黄色标签  
   - 接口（type=2）：绿色标签
2. **图标区分**：根据资源类型使用不同的图标
3. **样式设计**：使用统一的样式规范，确保视觉一致性

### 3.4 操作按钮实现

1. **编辑按钮**：跳转到已有的编辑资源页，携带资源 ID
2. **添加下级按钮**：跳转到已有的新增资源页，携带父级资源 ID
3. **删除按钮**：使用 n-popconfirm 实现二次确认，确认后调用删除接口并更新树数据
4. **查看按钮**：跳转到已有的查看资源页，携带资源 ID

## 4. 代码实现细节

### 4.1 资源树组件（tree.vue）

**模板结构**：
```vue
<template>
  <div class="resource-tree-page">
    <!-- 搜索区域 -->
    <div class="search-bar">
      <n-input
        v-model:value="searchText"
        placeholder="请输入资源名称"
        clearable
        @update:value="handleSearch"
      />
    </div>
    
    <!-- 资源树 -->
    <n-tree
      :data="treeData"
      :expanded-keys="expandedKeys"
      :render="renderTreeItem"
      :filter="filterTree"
    />
  </div>
</template>
```

**核心逻辑**：
- 使用 `ref` 管理搜索文本、树数据和展开节点
- 使用 `computed` 处理过滤后的树数据
- 实现 `renderTreeItem` 函数自定义树节点渲染
- 实现 `filterTree` 函数处理搜索过滤

### 4.2 树节点渲染（renderTreeItem）

```typescript
const renderTreeItem = (node: any) => {
  const resource = node.data as ResourceTree;
  return h('div', { class: 'tree-node-wrapper' }, [
    // 资源类型标签
    h(NTag, {
      type: getResourceTypeColor(resource.type),
      size: 'small',
      class: 'mr-2'
    }, {
      default: () => getResourceTypeName(resource.type)
    }),
    // 资源名称
    h('span', { class: 'resource-name' }, resource.name),
    // 操作按钮组
    h('div', { class: 'operation-buttons' }, [
      h(NButton, {
        size: 'tiny',
        type: 'primary',
        quaternary,
        onClick: () => handleEdit(resource)
      }, '编辑'),
      h(NButton, {
        size: 'tiny',
        type: 'success',
        quaternary,
        onClick: () => handleAddChild(resource)
      }, '添加下级'),
      h(NButton, {
        size: 'tiny',
        type: 'info',
        quaternary,
        onClick: () => handleView(resource)
      }, '查看'),
      h(NPopconfirm, {
        onPositiveClick: () => handleDelete(resource.id)
      }, {
        trigger: () => h(NButton, {
          size: 'tiny',
          type: 'error',
          quaternary
        }, '删除'),
        default: () => '确定删除该资源吗？'
      })
    ])
  ]);
};
```

### 4.3 资源类型辅助函数

```typescript
// 获取资源类型名称
const getResourceTypeName = (type: number): string => {
  const typeMap: Record<number, string> = {
    1: '页面',
    2: '接口',
    3: '模块'
  };
  return typeMap[type] || '未知';
};

// 获取资源类型颜色
const getResourceTypeColor = (type: number): string => {
  const colorMap: Record<number, string> = {
    1: 'info',
    2: 'success',
    3: 'warning'
  };
  return colorMap[type] || 'default';
};
```

### 4.4 操作函数实现

```typescript
// 编辑资源
const handleEdit = (resource: ResourceTree) => {
  router.push(`/system-manage/resource/edit?id=${resource.id}`);
};

// 添加下级资源
const handleAddChild = (resource: ResourceTree) => {
  router.push(`/system-manage/resource/create?parentId=${resource.id}`);
};

// 查看资源
const handleView = (resource: ResourceTree) => {
  router.push(`/system-manage/resource/detail?id=${resource.id}`);
};

// 删除资源
const handleDelete = async (id: string) => {
  const [, error] = await deleteResource(id);
  if (error) {
    message.error(`删除失败: ${error.message}`);
    return;
  }
  message.success('删除成功');
  // 重新获取资源树数据
  await fetchResourceTree();
};
```

## 5. 样式设计

### 5.1 树节点样式

```scss
.tree-node-wrapper {
  display: flex;
  align-items: center;
  justify-content: space-between;
  width: 100%;
  padding: 4px 0;
}

.resource-name {
  flex: 1;
  margin: 0 8px;
}

.operation-buttons {
  display: flex;
  gap: 4px;
}
```

### 5.2 页面布局样式

```scss
.resource-tree-page {
  padding: 16px;
  background-color: #fff;
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.search-bar {
  margin-bottom: 16px;
  display: flex;
  gap: 8px;
}
```

## 6. 性能优化

1. **懒加载**：考虑实现树节点懒加载，提高大数据量下的渲染性能
2. **虚拟滚动**：对于大型树结构，使用虚拟滚动优化性能
3. **缓存机制**：缓存资源树数据，减少重复请求

## 7. 测试与验证

1. **功能测试**：验证资源树展示、搜索过滤、操作按钮等功能
2. **性能测试**：测试大数据量下的页面性能
3. **兼容性测试**：确保在不同浏览器下正常显示
4. **代码质量**：确保代码符合 TypeScript 类型规范和前端开发规范

## 8. 开发规范遵循

1. **命名规范**：
   - 组件名称：大驼峰命名（如 ResourceTreeItem.vue）
   - 变量名称：驼峰命名（如 resourceTreeData）
   - 函数名称：驼峰命名（如 handleSearch）

2. **TypeScript 类型使用**：
   - 使用 `interface` 定义组件 props 和事件
   - 避免使用 `any` 类型
   - 使用泛型提高代码复用性

3. **UI 组件库使用**：
   - 使用 Naive UI 组件库
   - 统一图标大小和样式
   - 遵循组件库设计规范

4. **代码风格**：
   - 使用 Prettier 格式化代码
   - 合理的代码注释
   - 清晰的代码结构

## 9. 进度安排

1. **第 1 步**：创建资源树页面组件和路由配置
2. **第 2 步**：实现资源树数据获取与渲染
3. **第 3 步**：实现资源类型 UI 区分
4. **第 4 步**：实现搜索过滤功能
5. **第 5 步**：实现操作按钮功能
6. **第 6 步**：添加样式设计
7. **第 7 步**：测试与优化

## 10. 预期效果

1. 清晰的树形结构展示所有资源
2. 直观的资源类型区分
3. 便捷的搜索过滤功能
4. 完整的资源操作功能
5. 良好的用户体验和性能

# 总结

本计划详细描述了资源树页面的开发方案，包括页面设计、核心功能实现、代码结构和开发规范。通过遵循该计划，可以高效地完成资源树页面的开发，满足用户需求并保持代码质量。